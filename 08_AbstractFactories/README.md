## Abstract Factory

#### そのパターンの用途、どんなケースに適用できるか
抽象的な部品が複数あり、その抽象的な部品を作るための抽象的なファクトリーが存在する  
出力したいものは一緒だけど、使いたい部品が違うというとき  

#### 作成したサンプルコードの概要説明
ユーザ情報をExcelまたはCSVから読み込み、画面に出力するという場合を考える。  
1行ごとにユーザ情報が書いてあるとする。  

出力するためには

1. ファイルをパースして、すべての行の情報を取り出す  
2. 1で取り出した行を1行ずつ解析し、User情報を出力する  

このような流れで出力する  

- 1の部分をパース用のクラス
- 2の部分を解析用のクラス

に分けて部品化し、ExcelのときとCSVのときで、それぞれ部品を作る

#### クラス図の説明
https://lucid.app/lucidchart/b7a557ce-d10e-467f-be55-745772a3c6a7/edit?viewport_loc=-36%2C-90%2C2487%2C1209%2CHWEp-vi-RSFO&invitationId=inv_2c902116-541a-4328-82b7-39f7804cd4b5

#### ソースコードの説明



#### そのパターンを適用した場合のメリット
今回の例でいうと、ここにさらにTSVでも処理したいと思った場合、Mainの処理は変更せずとも機能を追加できる。  
（自分のコードだと、Factoryを作成している部分のswitchの文を修正しないといけないので、ここも修正しなくていいような工夫がいる）


#### メモ
抽象クラスを継承した抽象クラス。使うの初めて。
FactoryMethodパターンを拡張している。
FactoryMethodパターンでは一つの部品しか作らないが、部品が複数個あるのが異なる

#### 課題
##### DLLから読み込むようなパターンで作ってMainの処理を全く変えないように構造変更する
DllVersionの配下がDLLから読み込むようにしたバージョン  
MyAbstractFactoryUsingDll.exe -> UserFactory.dll <- UserFactoryの具象クラスのdll  
のような参照関係になっており、UserFactory.dllのインターフェースに基づいてすべて実装している  

Mainから呼び出す際は dllのファイル名と実際に解析したいファイルのパスを渡す想定。

dllのファイル名と同じクラス名のクラスが具体的なFactoryクラスであるという規約を定め、その規約どおりに作ってくれれば、dllを追加するだけで機能追加できるようになっている。  

##### CSVのFactoryの追加
TODO...